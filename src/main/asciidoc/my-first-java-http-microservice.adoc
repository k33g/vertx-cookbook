== Creating a discoverable http (reactive) microservice

NOTE: We'll see the following topics: how to create a simple *http (REST)* microservice, how to use a discovery backend to register it, and finally, how to use this microservice.

WARNING: We'll use the Redis Vert.x discovery backend, so, you need to install a Redis server

=== Bootstrapping a Maven project "from scratch"

NOTE: you can git clone link:https://github.com/vert-x3/vertx-maven-starter[vertx-maven-starter] but it's more instructive to know how to do things "by hand".

==== Project structure

To create the project structure you can type this command: 
```
mkdir -p myservice/src/{main,test}/java/io/vertx/starter
```
_(where `myservice` is the name of your project)._

Then you`ll get this structure:

```
myservice/
└── src
    ├── main
    │   └── java
    │       └── io
    │           └── vertx
    │               └── starter
    └── test
        └── java
            └── io
                └── vertx
                    └── starter
```

==== Main Class

Now, create an empty Java file: `myservice/src/main/java/io/vertx/starter/MyService.java`

==== pom.xml file

Then create the *Maven* `pom.xml` file at the root of the project:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.typeunsafe</groupId>
  <artifactId>myservice</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <vertx.version>3.4.2</vertx.version>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <main.verticle>io.vertx.starter.MyService</main.verticle>
  </properties>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.1</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>2.3</version>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>shade</goal>
            </goals>
            <configuration>
              <transformers>
                <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                  <manifestEntries>
                    <Main-Class>io.vertx.core.Launcher</Main-Class>
                    <Main-Verticle>${main.verticle}</Main-Verticle>
                  </manifestEntries>
                </transformer>
                <transformer implementation="org.apache.maven.plugins.shade.resource.AppendingTransformer">
                  <resource>META-INF/services/io.vertx.core.spi.VerticleFactory</resource>
                </transformer>
              </transformers>
              <artifactSet>
              </artifactSet>
              <outputFile>${project.build.directory}/${project.artifactId}-${project.version}-fat.jar
              </outputFile>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-core</artifactId>
      <version>${vertx.version}</version>
    </dependency>

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-java</artifactId>
      <version>${vertx.version}</version>
    </dependency>

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web</artifactId>
      <version>${vertx.version}</version>
    </dependency>

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-client</artifactId>
      <version>${vertx.version}</version>
    </dependency>

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-service-discovery</artifactId>
      <version>${vertx.version}</version>
    </dependency>

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-service-discovery-backend-redis</artifactId>
      <version>${vertx.version}</version>
    </dependency>

  </dependencies>
</project>
----

NOTE: `vertx-rx-java` is to use link:http://vertx.io/docs/vertx-rx/java[the rxified version of Vert.x]

NOTE: about `vertx-service-discovery-backend-redis`, we'll use link:http://vertx.io/docs/vertx-service-discovery-backend-redis/java[the RedisVert.x Discovery Backend]

NOTE: `vertx-web-client`, we'll use the web client to test our microservice.

=== Preparing MyService.java

This is the minimalist source code of your class:

[source, java]
----
package io.vertx.starter;

import io.vertx.rxjava.core.AbstractVerticle;
import io.vertx.core.Future;

public class MyService extends AbstractVerticle {

  public void stop(Future<Void> stopFuture) {
    // foo
  }

  public void start() {
    // foo
  }
}
----

An http microservice is an `AbstractVerticle` with a `start()` and a `stop()` methods. An http microservice is a web application, so we're going to define and start an http server (with a router) inside the `start()`. Update the `MyService.java` file like that:

[source, java]
----
package io.vertx.starter;

import io.vertx.rxjava.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.rxjava.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.rxjava.ext.web.Router;
import io.vertx.rxjava.ext.web.handler.StaticHandler;
import io.vertx.rxjava.ext.web.handler.BodyHandler;
import java.util.Optional;

public class MyService extends AbstractVerticle {

  public void stop(Future<Void> stopFuture) {
    // foo
  }

  public void start() {

    /**
     * Define routes and router
     */
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());

    router.get("/api/hello").handler(context -> {
      context.response()
        .putHeader("content-type", "application/json;charset=UTF-8")
        .end(
          new JsonObject().put("message", "👋 Hello 🌍").toString()
        );
    });

    /**
     * Start the server the microservice
     */
    Integer httpPort = Integer.parseInt(Optional.ofNullable(System.getenv("PORT")).orElse("8080"));
    HttpServer server = vertx.createHttpServer();

    server
      .requestHandler(router::accept)
      .rxListen(httpPort)
      .subscribe(
        httpserver -> { // success
          System.out.println("🌍 Listening on " + httpserver.actualPort());
        },
        failure -> {
          System.out.println("😡 Houston, we have a problem: " + failure.getMessage());
        }
      );
  }
}
----

So, you can build your application:

```
mvn clean package
```

and run it:

```
java -jar target/myservice-1.0-SNAPSHOT-fat.jar
```

and now you can call your microservice:

```
curl http://localhost:8080/api/hello
```

and you'll get:

```
{"message":"👋 Hello 🌍"}
```

=== Making the service discoverable

Your other applications must be able to "discover" your microservice. For this your microservice must register in a discovery backend (more informations: link:http://vertx.io/docs/vertx-service-discovery/java/#_backend[]). For this example, I would not use the native backend of Vert.x, but rather the Redis `ServiceDiscoveryBackend`.

==== ServiceDiscovery 

So, the microservice must create its own `ServiceDiscovery` instance to use the discovery infrastructure:

[source, java]
----
ServiceDiscoveryOptions serviceDiscoveryOptions = new ServiceDiscoveryOptions();
// Redis settings
Integer redisPort = Integer.parseInt(Optional.ofNullable(System.getenv("REDIS_PORT")).orElse("6379"));
String redisHost = Optional.ofNullable(System.getenv("REDIS_HOST")).orElse("127.0.0.1");
String redisAuth = Optional.ofNullable(System.getenv("REDIS_PASSWORD")).orElse(null);
// the redis hash
String redisRecordsKey = Optional.ofNullable(System.getenv("REDIS_RECORDS_KEY")).orElse("vert.x.ms");    

discovery = ServiceDiscovery.create(
  vertx,
  serviceDiscoveryOptions.setBackendConfiguration(
    new JsonObject()
      .put("host", redisHost)
      .put("port", redisPort)
      .put("auth", redisAuth)
      .put("key", redisRecordsKey)
  )
);    
----

==== Record 

After that, the microservice define a record with the informations to publish:

[source, java]
----
String serviceName = Optional.ofNullable(System.getenv("SERVICE_NAME")).orElse("my-service");
String serviceHost = Optional.ofNullable(System.getenv("SERVICE_HOST")).orElse("localhost"); 
Integer servicePort = Integer.parseInt(Optional.ofNullable(System.getenv("SERVICE_PORT")).orElse("8080"));
String serviceRoot = Optional.ofNullable(System.getenv("SERVICE_ROOT")).orElse("/api");

// create the microservice record
record = HttpEndpoint.createRecord(
  serviceName,
  serviceHost,
  servicePort,
  serviceRoot
);
// add some metadata (it's optional)
record.setMetadata(new JsonObject()
  .put("kind", "http")
  .put("message", "Hello 🌍")
  .put("uri", "/hello")
);

----

==== Registration 

And, then the microservice can publish its informations (the record) to the backend infrastructue:

[source, java]
----
discovery
  .rxPublish(record)
  .subscribe(
    succesfulRecord -> {
      System.out.println("😃 Microservice is published! " + succesfulRecord.getRegistration());
    },
    failure -> {
      System.out.println("😡 Not able to publish the microservice: " + failure.getMessage());
    }
  );
----

==== Unregistration 

The unregistration process is defined inside the `stop()` method of the verticle:

[source, java]
----
public void stop(Future<Void> stopFuture) {
  System.out.println("Unregistration process is started ("+record.getRegistration()+")...");

  discovery
    .rxUnpublish(record.getRegistration())
    .subscribe(
      successfulResult -> {
        System.out.println("👋 bye bye " + record.getRegistration());
        stopFuture.complete();
      },
      failure -> {
        failure.getCause().printStackTrace();
        System.out.println("😡 Unable to unpublish the microservice: " + failure.getMessage());
      }
    );
}
----

=== The "final" source code 

The definitive source code of our class is the following:

[source, java]
----
package io.vertx.starter;

import io.vertx.rxjava.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.rxjava.core.http.HttpServer;
import io.vertx.core.json.JsonObject;
import io.vertx.rxjava.ext.web.Router;
import io.vertx.rxjava.ext.web.handler.BodyHandler;
import io.vertx.rxjava.servicediscovery.types.HttpEndpoint;
import io.vertx.rxjava.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.Record;
import java.util.Optional;

public class MyService extends AbstractVerticle {

  private ServiceDiscovery discovery;
  private Record record;

  public void stop(Future<Void> stopFuture) {
    System.out.println("Unregistration process is started ("+record.getRegistration()+")...");

    discovery
      .rxUnpublish(record.getRegistration())
      .subscribe(
        successfulResult -> {
          System.out.println("👋 bye bye " + record.getRegistration());
          stopFuture.complete();
        },
        failure -> {
          failure.getCause().printStackTrace();
          System.out.println("😡 Unable to unpublish the microservice: " + failure.getMessage());
        }
      );
  }
  public void start() {

    /**
     * Define Discovery service
     */
    ServiceDiscoveryOptions serviceDiscoveryOptions = new ServiceDiscoveryOptions();
    // Redis settings
    Integer redisPort = Integer.parseInt(Optional.ofNullable(System.getenv("REDIS_PORT")).orElse("6379"));
    String redisHost = Optional.ofNullable(System.getenv("REDIS_HOST")).orElse("127.0.0.1");
    String redisAuth = Optional.ofNullable(System.getenv("REDIS_PASSWORD")).orElse(null);
    // the redis hash
    String redisRecordsKey = Optional.ofNullable(System.getenv("REDIS_RECORDS_KEY")).orElse("vert.x.ms");    
    
    discovery = ServiceDiscovery.create(
      vertx,
      serviceDiscoveryOptions.setBackendConfiguration(
        new JsonObject()
          .put("host", redisHost)
          .put("port", redisPort)
          .put("auth", redisAuth)
          .put("key", redisRecordsKey)
      ));    

    String serviceName = Optional.ofNullable(System.getenv("SERVICE_NAME")).orElse("my-service");
    String serviceHost = Optional.ofNullable(System.getenv("SERVICE_HOST")).orElse("localhost"); 
    Integer servicePort = Integer.parseInt(Optional.ofNullable(System.getenv("SERVICE_PORT")).orElse("8080"));
    String serviceRoot = Optional.ofNullable(System.getenv("SERVICE_ROOT")).orElse("/api");

    // create the microservice record
    record = HttpEndpoint.createRecord(
      serviceName,
      serviceHost,
      servicePort,
      serviceRoot
    );
    // add some metadata
    record.setMetadata(new JsonObject()
      .put("kind", "http")
      .put("message", "Hello 🌍")
      .put("uri", "/hello")
    );

    /**
     * Define routes and router
     */
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());

    router.get("/api/hello").handler(context -> {
      context.response()
        .putHeader("content-type", "application/json;charset=UTF-8")
        .end(
          new JsonObject().put("message", "👋 Hello 🌍").toString()
        );
    });

    /**
     * Start the server the microservice
     */
    Integer httpPort = Integer.parseInt(Optional.ofNullable(System.getenv("PORT")).orElse("8080"));
    HttpServer server = vertx.createHttpServer();

    server
      .requestHandler(router::accept)
      .rxListen(httpPort)
      .subscribe(
        httpserver -> { // success
          System.out.println("🌍 Listening on " + httpserver.actualPort());

          discovery
            .rxPublish(record)
            .subscribe(
              succesfulRecord -> {
                System.out.println("😃 Microservice is published! " + succesfulRecord.getRegistration());
              },
              failure -> {
                System.out.println("😡 Not able to publish the microservice: " + failure.getMessage());
              }
            );
        },
        failure -> {
          System.out.println("😡 Houston, we have a problem: " + failure.getMessage());
        }
      );
  }
}
----

==== Run it

Now, launch `redis-server`, build you jar file (`mvn clean package`),and run it (`java -jar target/myservice-1.0-SNAPSHOT-fat.jar`). Then you`ll get something like that:

```
🌍 Listening on 8080
😃 Microservice is published! b2decac3-9e6c-4d4a-83e7-7d65dd1f75f2
```

And if you type this command `hgetall vert.x.ms` with a redis client, you'll get this:

```
{
  "location":{
    "endpoint":"http://localhost:8080/api",
    "host":"localhost",
    "port":8080,
    "root":"/api",
    "ssl":false
  },
  "metadata":{
    "kind":"http",
    "message":"Hello 🌍",
    "uri":"/hello"},
    "name":"my-service",
    "registration":"b2decac3-9e6c-4d4a-83e7-7d65dd1f75f2",
    "status":"UP",
    "type":"http-endpoint"
  }
}
```

NOTE: `vert.x.ms` is define inside the code when setting the redis informations (`String redisRecordsKey = Optional.ofNullable(System.getenv("REDIS_RECORDS_KEY")).orElse("vert.x.ms");`)

And if you quit the java application, you'll get:

```
👋 bye bye b2decac3-9e6c-4d4a-83e7-7d65dd1f75f2
```

==== Now, disvover it

The code for "discovering" a microservice looks like this:

[source, java]
----
// searching for microservice named "my-service"
discovery
  .rxGetRecord(r -> r.getName().equals("my-service"))
  .subscribe(
    successfulRecord -> {
      System.out.println(successfulRecord.toJson().encodePrettily());
    },
    failure -> {
      System.out.println("😡 Unable to discover the service: " + failure.getMessage());
    }
  );
----

or you can do this if you want to get all the registered microservices:

[source, java]
----
// 👋 searching for microservices
discovery
  .rxGetRecords((JsonObject) null)
  .subscribe(
    successfulRecords -> {
      String message = successfulRecords.size() > 0 
        ? "😋 " + successfulRecords.size() + " record(s) found."
        : "😢 no record found" ;
      System.out.println(message);
      
      successfulRecords.forEach(item -> {
        System.out.println(item.toJson());                
      });
    },
    failure -> {
      System.out.println("😡 Unable to discover the services: " + failure.getMessage());
    }
  );
----

We will therefore write modify our class to implement this discovery process. So, copy-paste the code below, after the subscribe "successful" part of the microservice:

[source, java]
----
server
  .requestHandler(router::accept)
  .rxListen(httpPort)
  .subscribe(
    httpserver -> { // success
      System.out.println("🌍 Listening on " + httpserver.actualPort());
      
      // 👋 searching for microservices
      discovery
        .rxGetRecords((JsonObject) null)
        .subscribe(
          successfulRecords -> {
            String message = successfulRecords.size() > 0 
              ? "😋 " + successfulRecords.size() + " record(s) found."
              : "😢 no record found" ;
            System.out.println(message);
            
            successfulRecords.forEach(item -> {
              System.out.println(item.toJson());                
            });
          },
          failure -> {
            System.out.println("😡 Unable to discover the services: " + failure.getMessage());
          }
        );

      discovery
        .rxPublish(record)
        .subscribe(
          succesfulRecord -> {
            System.out.println("😃 Microservice is published! " + succesfulRecord.getRegistration());
          },
          failure -> {
            System.out.println("😡 Not able to publish the microservice: " + failure.getMessage());
          }
        );
    },
    failure -> {
      System.out.println("😡 Houston, we have a problem: " + failure.getMessage());
    }
  );
----

Now, build again your microservice, then open a terminal and run this command:

```
SERVICE_NAME="HELLO-SERVICE" SERVICE_PORT=8081 PORT=8081 java -jar target/myservice-1.0-SNAPSHOT-fat.jar
```

You'll get something like that:

```
🌍 Listening on 8081
😢 no record found
😃 Microservice is published! 51d24337-c0f0-4f36-8b0a-76ff0090cf93
```

NOTE: `SERVICE_PORT` is the registered port of the microservice, `PORT` is the http port of the hhtp server. They could be different if you run it inside a virtual machine or inside a container.

Now, open an other terminal, and run this command:

```
SERVICE_NAME="HI-SERVICE" SERVICE_PORT=8082 PORT=8082 java -jar target/myservice-1.0-SNAPSHOT-fat.jar
```

You'll get this:

```
🌍 Listening on 8082
😋 1 record(s) found.
{"location":{"endpoint":"http://localhost:8081/api","host":"localhost","port":8081,"root":"/api","ssl":false},"metadata":{"kind":"http","message":"H
ello 🌍","uri":"/hello"},"name":"HELLO-SERVICE","registration":"51d24337-c0f0-4f36-8b0a-76ff0090cf93","status":"UP","type":"http-endpoint"}
😃 Microservice is published! da843e0f-8099-4760-9f7e-48847faa0e72
```

The new service has well detected the previous one.

You can check the records with the redis client with this command: `hgetall vert.x.ms`.

```
{"location":{"endpoint":"http://localhost:8082/api","host":"localhost","port":8082,"root":"/api","ssl":false},"metadata":{"kind":"http","message":"Hello 🌍","uri":"/hello"},"name":"HI-SERVICE","registration":"da843e0f-8099-4760-9f7e-48847faa0e72","status":"UP","type":"http-endpoint"}

{"location":{"endpoint":"http://localhost:8081/api","host":"localhost","port":8081,"root":"/api","ssl":false},"metadata":{"kind":"http","message":"Hello 🌍","uri":"/hello"},"name":"HELLO-SERVICE","registration":"51d24337-c0f0-4f36-8b0a-76ff0090cf93","status":"UP","type":"http-endpoint"}
```

That's all for the moment. Stay tuned for the next episode 👋.

